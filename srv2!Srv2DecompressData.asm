srv2!Srv2DecompressData:
fffff801`3b587e60 488bc4          mov     rax,rsp
fffff801`3b587e63 48895810        mov     qword ptr [rax+10h],rbx
fffff801`3b587e67 48896818        mov     qword ptr [rax+18h],rbp
fffff801`3b587e6b 48897020        mov     qword ptr [rax+20h],rsi				
; typical fastcall conventionï¼Œ because registers are used without initialization
; rcx,rdx,r8,r9 will be left->right param, others will be saved into stack
fffff801`3b587e6f 57              push    rdi
fffff801`3b587e70 4156            push    r14
fffff801`3b587e72 4157            push    r15
; this is something like new 40h bytes from stack memory
; it's actually 64 bytes, and I have no idea what it is used for so far
fffff801`3b587e74 4883ec40        sub     rsp,40h
; here, you're accessing a 8byte size data in the stack
; this is a old data, it is push into stack before you enter into this function
; is it the return address of the caller?
; let's check it out with windbg(x64)
; from the call stack when the target machine crashed, the caller of this function should be 
; tips: in x64 code, bp is always 0x0, there is only one stack frame, so it is normal that there is no instructions like `move rbp, rsp`
; damn it, I'm so stupid, rax+8 just skip the return addr of the caller, so rax+8 should be an old value which is pushed before entering this function
; here is the stack analysis: https://i.ibb.co/LPSCv7C/QQ-20220607135423.png
; so `and     dword ptr [rax+8],0` just initialize 4bytes non-initialized stack area(32bytes total)
fffff801`3b587e78 83600800        and     dword ptr [rax+8],0
; here the first param to this function is transfered to rdi
fffff801`3b587e7c 488bf9          mov     rdi,rcx
; rcx[0xF0] -> rax
; ddp rcx+f0 L2, seems like an addr
	; ffffc805`b6dc7100  5fa0a150
	; ffffc805`b6dc7104  ffffd903
fffff801`3b587e7f 488b81f0000000  mov     rax,qword ptr [rcx+0F0h]
; compare rcx[0xF0][x24] with 0x10
; ddp ffffd9035fa0a150+24 L1
	; ffffc805`b797f174  00000410
; if you have wireshark captured this packet, you will find the smb packet is exactly 0x410 which is 1040 bytes
; https://i.ibb.co/g4JnJtr/QQ-20220607135423.png
; and if you have read the spec from Microsoft: https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-SMB2/%5bMS-SMB2%5d-200304.pdf
; you will notice this: https://i.ibb.co/TkLQMp9/QQ-20220607135423.png
; so `cmp     dword ptr [rax+24h],10h` is an implement of spec
; it compares the message and header size
; so rcx should be a pointer to packet(I didn't say it is the smb packet), in the offset 0xF0 of it, is another pointer, and it contains some valuable info
; clearly bigger than 0x10, so jump will not be taken
fffff801`3b587e86 83782410        cmp     dword ptr [rax+24h],10h
fffff801`3b587e8a 0f8204010000    jb      srv2!Srv2DecompressData+0x134 (fffff801`3b587f94)  Branch

srv2!Srv2DecompressData+0x30:
; let's see what's in offset 0x18
; ddp rax+18
	; ffffd903`5fa0a168  5fa09050
	; ffffd903`5fa0a16c  ffffd903
; still, seems like an address
; let's check the content of it
; ddp ffffd9035fa09050
; https://i.ibb.co/Gp9MCdk/QQ-20220607135423.png
; yes, it is indeed the smbpacket address
; param_1[0xF0][0x18] is the pointer to the real content of our elaborate payload
fffff801`3b587e90 488b4018        mov     rax,qword ptr [rax+18h]
; now 128bit->16bytes from the beginning of our payload is copyd to xmm0 register, it is a 128bit register
fffff801`3b587e94 0f1000          movups  xmm0,xmmword ptr [rax]
; rcx is still param_1, value has not been changed, so let's what in it
; ddp rcx+50
	; ffffd903`5f43b4b0  5fa06a80
	; ffffd903`5f43b4b4  ffffd903
; another address
fffff801`3b587e97 488b4150        mov     rax,qword ptr [rcx+50h]
; value in xmm0 is stored into stack
; https://i.ibb.co/nQydqdK/QQ-20220607135423.png
fffff801`3b587e9b 0f11442430      movups  xmmword ptr [rsp+30h],xmm0
; rax is an address, and we are accessing the 0x1F0 offset of this addr
; rcx[0x50][0x1F0], I have no idea what is it, and I didn't see this in the offical spec
; ddp ffffd9035fa06a80+1f0
	; ffffd903`5fa06c70  5fa06c80
	; ffffd903`5fa06c74  ffffd903
; still an addr
fffff801`3b587ea0 488b88f0010000  mov     rcx,qword ptr [rax+1F0h]
; right shift xmm0 8bytes(attention please! 8 bytes not 8 bit)
; which means the whole lower 64bit is dropped and replace with upper 64bit, and upper 64bit is cleared
fffff801`3b587ea7 660f73d808      psrldq  xmm0,8
; ddp ffffd9035fa06c80+8c
	; ffffd903`5fa06d0c  00000001
; so ebp->1
; in fact, we can calculate like this: ddp poi(poi(rcx+50)+1F0)+8c
; https://i.ibb.co/yPcrzz6/QQ-20220607135423.png
fffff801`3b587eac 8ba98c000000    mov     ebp,dword ptr [rcx+8Ch]
; xmm0 -> rcx
fffff801`3b587eb2 66480f7ec1      movq    rcx,xmm0
; and we extract the lower 16bit of rcx to eax
; from the above record, value in xmm0 is now `00000000 00000000 ffffffff ffff0001`
; rcx is only 8bytes, so rcx -> `ffffffff ffff0001`
; cx -> `0001`
; same as ebp, so je is taken
fffff801`3b587eb7 0fb7c1          movzx   eax,cx
fffff801`3b587eba 3be8            cmp     ebp,eax
fffff801`3b587ebc 740a            je      srv2!Srv2DecompressData+0x68 (fffff801`3b587ec8)  Branch

srv2!Srv2DecompressData+0x5e:
fffff801`3b587ebe b8bb0000c0      mov     eax,0C00000BBh
fffff801`3b587ec3 e9d1000000      jmp     srv2!Srv2DecompressData+0x139 (fffff801`3b587f99)  Branch

srv2!Srv2DecompressData+0x68:
; with je, now we come here
; [rsp+30h] is the old value of xmm0, which is the first 16bytes of our payload
; but rax can only handle 64bit of it, so rax -> `00000400 424d53fc`
fffff801`3b587ec8 488b442430      mov     rax,qword ptr [rsp+30h]
fffff801`3b587ecd 33d2            xor     edx,edx
; rax and rcx both right shift 0x20, wichi means the lower 32bit is replaced by upper 32bit, and upper 32bit is cleared
; after that, rax -> `00000000 00000400`, rcx -> `00000000 ffffffff`
fffff801`3b587ecf 48c1e820        shr     rax,20h
fffff801`3b587ed3 48c1e920        shr     rcx,20h
; with this instruction, overflow is occured
; you see, ecx can only handle 16bit, and it is already the max value `ffffffff`
; and add operate to ecx will make it returns to the beginning of the `circle`
; https://twitter.com/include233333/status/1534040669504667648
; let's move on
fffff801`3b587ed7 03c8            add     ecx,eax
; I need to dive into this function to see, how the buffer is allocated, and how many buffer is allocated
fffff801`3b587ed9 4c8b15489a0200  mov     r10,qword ptr [srv2!_imp_SrvNetAllocateBuffer (fffff801`3b5b1928)]
fffff801`3b587ee0 e84be8f8ff      call    srvnet!SrvNetAllocateBuffer (fffff801`3b516730)
; I supposed rax is the return value of srvnet!SrvNetAllocateBuffer
; and it should be an address of the allocated buffer
; because there is a test to rax, just check if it is zero, this is a typical return value check code
; to make sure the call is successed or not
fffff801`3b587ee5 488bd8          mov     rbx,rax
fffff801`3b587ee8 4885c0          test    rax,rax
fffff801`3b587eeb 750a            jne     srv2!Srv2DecompressData+0x97 (fffff801`3b587ef7)  Branch

srv2!Srv2DecompressData+0x8d:
fffff801`3b587eed b89a0000c0      mov     eax,0C000009Ah
fffff801`3b587ef2 e9a2000000      jmp     srv2!Srv2DecompressData+0x139 (fffff801`3b587f99)  Branch

srv2!Srv2DecompressData+0x97:
; with a jne, we come here
; rbx is now the allocated buffer address
; just a bunch of random value in it
; ddp rbx
; https://img-blog.csdnimg.cn/c8bd0ef8172e446ca2d6fd9deba638c4.png
; long time no see! rdi!
; almost forget you, rdi holds the value of param_1
; again, offset 0xF0, the address in it is transfered to rdx
fffff801`3b587ef7 488b97f0000000  mov     rdx,qword ptr [rdi+0F0h]
fffff801`3b587efe 8bcd            mov     ecx,ebp
; value in offset 0x18 of allocated buffer is transfered to r9, this is the fourth param to fastcall convention
; maybe it is some header thing or what
fffff801`3b587f00 4c8b4818        mov     r9,qword ptr [rax+18h]
; idk what's in [rsp+3c]
; oh! I know, remember [rsp+30]? we saved a 16bytes value in it, if we divide it into 4 4bytes values
; then [rsp+3c] should be the last 4bytes value, which is `ffffffff`
; this is the offset/length field of our payload
fffff801`3b587f04 8b74243c        mov     esi,dword ptr [rsp+3Ch]
; and [rsp+34] as a dword is `00000400`, which is the OriginalSize field of our payload
fffff801`3b587f08 448b742434      mov     r14d,dword ptr [rsp+34h]
; idk the meaning of r9+rsi, I just know rsi is offset, and r9 is the value in addr (allocated buffer beginning addr+0x18)
; for some reason that idk, r9 is pointed to another smb packet, I see the smb ProtocolId `424d53fe`
; https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/fb188936-5050-48d3-b350-dc43059638a4
; and this is not our payload, protocolid in our payload is `424d53fc`
; `424d53fe` represents normal smb2 packet without compress feature
; just cleard my thoughts, it is reasonabel in fact, this function is doing decompress right?
; so the compressed packet should be decompress as normal smb2 packet, so after we get the allocated buffer,
; we make the buffer to be a smb packet, and we fill the protocolid field with `424d53fe`
; this make sense to me, something must have been done in function srvnet!SrvNetAllocateBuffer
; I'll restart the debugger to check this
; before I restart, I found this in the offical spec, which means I maybe right
; https://img-blog.csdnimg.cn/d7828719b82040b085a819831b817b8e.png
; anyway, I'll check this
; emmm, is it coincidence? this time the value r9 pointed to is meaningless
; anyway, let's move on
; so this is an addr plus offset in our payload, which is 0xffffffff
; after this, r9 is pointing to somewhere with uninitialized data
; WTF? I run debugger again, and now ddp r9 is ProtocolId `424d53fe`
; maybe my debugger is fucked
; seems like the content in the memory and register is dynamic
fffff801`3b587f0d 4c03ce          add     r9,rsi
; r8 is the third param in fastcall, r8d is the lower 32bit of r8 register
fffff801`3b587f10 448b4224        mov     r8d,dword ptr [rdx+24h]
; now rdx[0x18] is the pointer to our payload
; so rdx[0x24] is pointed to the offset, because all the fields in header before offset is total 0xC bytes
; r8d -> 0xffffffff
; rax is now the pointer to smb header
; oh no no no, I made a mistake, rdx[0x24] is not comparable to rdx[0x18]
; these two both are pointer, rdx[0x18] is the smbheader, and rdx[0x24] is totally something else
; somehow, rdx[0x18] is the value of packet size 1040bytes
; oh, I figured it out
; rember the size comparing?
; `cmp     dword ptr [rax+24h],10h`
; back to this instruction, [rax+0x24] => rcx[0xF0][0x24]
; here `mov     r8d,dword ptr [rdx+24h]`
; [rdx+24hh] => rdi[0xF0][0x24]
; rdi holds the value of param_1, which is the same as rcx
; so it makes sense that [rdx+24h] is the size of smbpacket
fffff801`3b587f14 488b4218        mov     rax,qword ptr [rdx+18h]
; r8d-esi => r8d - (-1) = r8d+1 = 1041 => 0x411
; when we do add operation, 0xffffffff => -1, because 0x0 + 0xffffffff = 0
; so 0xffffffff = -1
; - (-1) => +1
fffff801`3b587f18 442bc6          sub     r8d,esi
; this will lead to overflow again, 0xffffffff+0x10=>0xf
; fuck me, I'm so careless, there is no overflow, because dest operand is 64bit register
; so rdx should be 0x000000010000000f
fffff801`3b587f1b 488d5	610        lea     rdx,[rsi+10h]
fffff801`3b587f1f 4183e810        sub     r8d,10h
; because the upper 32bit of rax is 1 
; so the final address would be far away
; this area is full of non-init data
; rdx is mean to be smb_header+header_length+offset
fffff801`3b587f23 4803d0          add     rdx,rax
; idk what does this mean, he just put rax point to somewhere in the stack and then copy this pointer to another place in stack
fffff801`3b587f26 488d442460      lea     rax,[rsp+60h]
; may be this is for parameter transfering?
; I need to record this two stack parameter
; rsp -> ffffe30158738e70
	; [rsp+28h]	ffffe30158738ed0  	->	Pointer of somewhere of the stack, this should be some data stored in the caller
	;									it's the same as rsp in the caller(3 push operation + call -> 3*8+8=32=0x20  rsp-40h+60h->rsp+20h -> rsp in the caller)
	; which is:
		; ffffdd09`27da1ed0  00000010
		; ffffdd09`27da1ed4  00000000
	; if you use ddp rax to see the data, you will notice that it is all 0, because there is an instruction in the beginning of this function: `and     dword ptr [rax+8],0`, which initiates the first 4bytes in this area
	; so [rsp+28h] is the rsp in the caller
	; [rsp+20h]	0000000000000400	->	OriginalSize
fffff801`3b587f2b 4889442428      mov     qword ptr [rsp+28h],rax
fffff801`3b587f30 4489742420      mov     dword ptr [rsp+20h],r14d
fffff801`3b587f35 4c8b1574990200  mov     r10,qword ptr [srv2!_imp_SmbCompressionDecompress (fffff801`3b5b18b0)]

; after memory is allocated, call this function, here is the parameter
; as fastcall, rcx, rdx, r8, r9 and stack
; so there are totally 6 param is passed to srvnet!SmbCompressionDecompress
; 4 register param, 2 stack param	
; rcx is the CompressionAlgorithm
; rdx is the pointer to unknow area
; r8 is the length of compressed data(which is also theoretically(packetsize-hedersize-offset), because an overflow occured)
; r9 -> [allocated buffer beginning addr + 0x18] + offset
; [rsp+28h]	ffffe30158738ed0  	->	Pointer of somewhere of the stack
; [rsp+20h]	0000000000000400	->	OriginalSize
; when rip is point to this instruction, if we push F10 in windbg to step over, the target system will crash
; os the magic of BSOD is happened here
; now let's step into it
fffff801`3b587f3c e86f65faff      call    srvnet!SmbCompressionDecompress (fffff801`3b52e4b0)
fffff801`3b587f41 85c0            test    eax,eax
fffff801`3b587f43 7840            js      srv2!Srv2DecompressData+0x125 (fffff801`3b587f85)  Branch

srv2!Srv2DecompressData+0xe5:
fffff801`3b587f45 8b442460        mov     eax,dword ptr [rsp+60h]
fffff801`3b587f49 413bc6          cmp     eax,r14d
fffff801`3b587f4c 7537            jne     srv2!Srv2DecompressData+0x125 (fffff801`3b587f85)  Branch

srv2!Srv2DecompressData+0xee:
fffff801`3b587f4e 85f6            test    esi,esi
fffff801`3b587f50 741f            je      srv2!Srv2DecompressData+0x111 (fffff801`3b587f71)  Branch

srv2!Srv2DecompressData+0xf2:
fffff801`3b587f52 488b87f0000000  mov     rax,qword ptr [rdi+0F0h]
fffff801`3b587f59 448bc6          mov     r8d,esi
fffff801`3b587f5c 488b4b18        mov     rcx,qword ptr [rbx+18h]
fffff801`3b587f60 488b5018        mov     rdx,qword ptr [rax+18h]
fffff801`3b587f64 4883c210        add     rdx,10h
fffff801`3b587f68 e85376ffff      call    srv2!memcpy (fffff801`3b57f5c0)
fffff801`3b587f6d 8b442460        mov     eax,dword ptr [rsp+60h]

srv2!Srv2DecompressData+0x111:
fffff801`3b587f71 03c6            add     eax,esi
fffff801`3b587f73 488bd3          mov     rdx,rbx
fffff801`3b587f76 488bcf          mov     rcx,rdi
fffff801`3b587f79 894324          mov     dword ptr [rbx+24h],eax
fffff801`3b587f7c e887f00200      call    srv2!Srv2ReplaceReceiveBuffer (fffff801`3b5b7008)
fffff801`3b587f81 33c0            xor     eax,eax
fffff801`3b587f83 eb14            jmp     srv2!Srv2DecompressData+0x139 (fffff801`3b587f99)  Branch

srv2!Srv2DecompressData+0x125:
fffff801`3b587f85 488bcb          mov     rcx,rbx
fffff801`3b587f88 4c8b1591990200  mov     r10,qword ptr [srv2!_imp_SrvNetFreeBuffer (fffff801`3b5b1920)]
fffff801`3b587f8f e87cd7f8ff      call    srvnet!SrvNetFreeBuffer (fffff801`3b515710)

srv2!Srv2DecompressData+0x134:
fffff801`3b587f94 b80b0900c0      mov     eax,0C000090Bh

srv2!Srv2DecompressData+0x139:
fffff801`3b587f99 488b5c2468      mov     rbx,qword ptr [rsp+68h]
fffff801`3b587f9e 488b6c2470      mov     rbp,qword ptr [rsp+70h]
fffff801`3b587fa3 488b742478      mov     rsi,qword ptr [rsp+78h]
fffff801`3b587fa8 4883c440        add     rsp,40h
fffff801`3b587fac 415f            pop     r15
fffff801`3b587fae 415e            pop     r14
fffff801`3b587fb0 5f              pop     rdi
fffff801`3b587fb1 c3              ret
