; save register value into stack
fffff804`4a476730 48895c2408      mov     qword ptr [rsp+8],rbx
fffff804`4a476735 48896c2410      mov     qword ptr [rsp+10h],rbp
fffff804`4a47673a 4889742418      mov     qword ptr [rsp+18h],rsi
fffff804`4a47673f 57              push    rdi
fffff804`4a476740 4156            push    r14
fffff804`4a476742 4157            push    r15
; give me some(0x30bytes) space in the stack
fffff804`4a476744 4883ec30        sub     rsp,30h
; idk what the fuck is this, maybe a constant value
; the value of it is 0x1
fffff804`4a476748 658b2c25a4010000 mov     ebp,dword ptr gs:[1A4h]
; init r15 to 0
fffff804`4a476750 4533ff          xor     r15d,r15d
; init esi to 0
fffff804`4a476753 418bf7          mov     esi,r15d
; rdx is 0, so r14 is init to 0
fffff804`4a476756 4c8bf2          mov     r14,rdx
; sil is the lower 8bit of rsi, 0x0
; https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture
; value of [srvnet!SrvDisableNetBufferLookAsideList] is 0x0
; jne will not be taken
fffff804`4a476759 403835a9e80200  cmp     byte ptr [srvnet!SrvDisableNetBufferLookAsideList (fffff804`4a4a5009)],sil
; inti edi to 0
fffff804`4a476760 410fb7ff        movzx   edi,r15w
fffff804`4a476764 0f8554d50000    jne     srvnet!SrvNetAllocateBuffer+0xd58e (fffff804`4a483cbe)  Branch

srvnet!SrvNetAllocateBuffer+0x3a:
; in our case, rcx is 0x3FF
; following two `ja` instructions will not be taken
fffff804`4a47676a 4881f900011000  cmp     rcx,100100h
fffff804`4a476771 0f8747d50000    ja      srvnet!SrvNetAllocateBuffer+0xd58e (fffff804`4a483cbe)  Branch

srvnet!SrvNetAllocateBuffer+0x47:
fffff804`4a476777 4881f900110000  cmp     rcx,1100h
fffff804`4a47677e 0f87aa000000    ja      srvnet!SrvNetAllocateBuffer+0xfe (fffff804`4a47682e)  Branch

srvnet!SrvNetAllocateBuffer+0x54:
; inti eax to 0
fffff804`4a476784 8bc6            mov     eax,esi
; now rcx points to `srvnet!SrvNetBufferLookasides`
fffff804`4a476786 488d0d63e90200  lea     rcx,[srvnet!SrvNetBufferLookasides (fffff804`4a4a50f0)]
; r8d -> 0x1
fffff804`4a47678d 440fb7c5        movzx   r8d,bp
; r8d -> 0x2
fffff804`4a476791 41ffc0          inc     r8d
; rax=0, os rax*8 is still 0
; rcx is now srvnet!SrvNetBufferLookasides[0]
; according to IDA reverse code, `srvnet!SrvNetBufferLookasides` is an array which has 9 elements
; so rax*8 is index, srvnet!SrvNetBufferLookasides[rax*8]
; rax may be 0/1, but from what I can see, rax has no chance to be 1;
; r15d -> esi -> eax, r15d is init to 0
fffff804`4a476794 488b0cc1        mov     rcx,qword ptr [rcx+rax*8]
; so srvnet!SrvNetBufferLookasides[0] is an address, now the value in it is stored in edx
; which is 0x03
fffff804`4a476798 8b11            mov     edx,dword ptr [rcx]
; compare with 0x2
; if r8d < edx, cmovb will execute
fffff804`4a47679a 443bc2          cmp     r8d,edx
; eax is now 0x2
fffff804`4a47679d 8d42ff          lea     eax,[rdx-1]
; cmovb will be executed
fffff804`4a4767a0 410f42c0        cmovb   eax,r8d
; edx -> 0x2
fffff804`4a4767a4 8bd0            mov     edx,eax
; rax -> srvnet!SrvNetBufferLookasides[0][0x20]
; looks like an addr, too
fffff804`4a4767a6 488b4120        mov     rax,qword ptr [rcx+20h]
; srvnet!SrvNetBufferLookasides[0][0x20][0x10]
; ddp poi(poi(fffff8044a4a50f0)+20)+10
; still an addr, rdi
; I have no idea what rdi is
fffff804`4a4767aa 488b3cd0        mov     rdi,qword ptr [rax+rdx*8]
; r15 is 0
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x70]
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+70 -> 0x1
; jne is taken
; idk what is all this for
fffff804`4a4767ae 44387f70        cmp     byte ptr [rdi+70h],r15b
fffff804`4a4767b2 7508            jne     srvnet!SrvNetAllocateBuffer+0x8c (fffff804`4a4767bc)  Branch

srvnet!SrvNetAllocateBuffer+0x84:
fffff804`4a4767b4 488bd7          mov     rdx,rdi
fffff804`4a4767b7 e8cc000000      call    srvnet!PplpLazyInitializeLookasideList (fffff804`4a476888)

srvnet!SrvNetAllocateBuffer+0x8c:
; with a jne, we come here
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x14] -> 0x1
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x14]++
fffff804`4a4767bc ff4714          inc     dword ptr [rdi+14h]
; rcx -> srvnet!SrvNetBufferLookasides[0][0x20][0x10]
fffff804`4a4767bf 488bcf          mov     rcx,rdi
fffff804`4a4767c2 4c8b15c7bb0200  mov     r10,qword ptr [srvnet!_imp_ExpInterlockedPopEntrySList (fffff804`4a4a2390)]
; idk what this function does, either
fffff804`4a4767c9 e8e2b73ffd      call    nt!ExpInterlockedPopEntrySList (fffff804`47871fb0)
; I guess rax is an error number this time
; rax -> 0, means success, jne not taken
fffff804`4a4767ce 488bd8          mov     rbx,rax
fffff804`4a4767d1 4885c0          test    rax,rax
fffff804`4a4767d4 751d            jne     srvnet!SrvNetAllocateBuffer+0xc3 (fffff804`4a4767f3)  Branch

srvnet!SrvNetAllocateBuffer+0xa6:
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x18]++
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+18 -> 0x1
; ++ -> 0x2
fffff804`4a4767d6 ff4718          inc     dword ptr [rdi+18h]
; rdi -> ffffe20f7f088ac0
; r9  -> ffffe20f7f088ac0
; 5 successive mov instructions, seems like it is passing parameters
fffff804`4a4767d9 4c8bcf          mov     r9,rdi
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x2C]
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x30]
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x28]
; srvnet!SrvNetBufferLookasides[0][0x20][0x10][0x24]
; 3 dword, 1 qword
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+2c   ->		00001100
; rax might be the callback function addr
; step into this call, you will see this:
; jmp     rax
; so yes, rax is the callback function addr
; called function name: `srvnet!PplGenericAllocateFunction`
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+30   -> 	fffff8044a47d5e0
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+28   -> 	3030534c
; ddp poi(poi(poi(fffff8044a4a50f0)+20)+10)+24   ->   	00000200
; I may need a clear structure of SrvNetBufferLookasides
fffff804`4a4767dc 8b572c          mov     edx,dword ptr [rdi+2Ch]
fffff804`4a4767df 488b4730        mov     rax,qword ptr [rdi+30h]
fffff804`4a4767e3 448b4728        mov     r8d,dword ptr [rdi+28h]
fffff804`4a4767e7 8b4f24          mov     ecx,dword ptr [rdi+24h]
; here again, dispatch, this time, a `fptr` suffix
; omit this function for now
fffff804`4a4767ea ff1578c10200    call    qword ptr [srvnet!_guard_dispatch_icall_fptr (fffff804`4a4a2968)]
; rax -> ffffe20f81a49150
; return value is an address, should be the new allocated buffer
; but how can I know size?
; transfer return value to rbx
fffff804`4a4767f0 488bd8          mov     rbx,rax

srvnet!SrvNetAllocateBuffer+0xc3:
fffff804`4a4767f3 bf02000000      mov     edi,2

srvnet!SrvNetAllocateBuffer+0xc8:
; je will not be taken
fffff804`4a4767f8 4885db          test    rbx,rbx
fffff804`4a4767fb 7415            je      srvnet!SrvNetAllocateBuffer+0xe2 (fffff804`4a476812)  Branch

srvnet!SrvNetAllocateBuffer+0xcd:
; do something with return value(address)
; last bit of rbx[0x10] is set to 1
fffff804`4a4767fd 66097b10        or      word ptr [rbx+10h],di
; init to 0
fffff804`4a476801 66897312        mov     word ptr [rbx+12h],si
; init to 1
fffff804`4a476805 66896b14        mov     word ptr [rbx+14h],bp
; r14 is 0, so jne not taken
fffff804`4a476809 4d85f6          test    r14,r14
fffff804`4a47680c 753b            jne     srvnet!SrvNetAllocateBuffer+0x119 (fffff804`4a476849)  Branch

srvnet!SrvNetAllocateBuffer+0xde:
; continue fuck with rbx(buffer address)
; init to 0
fffff804`4a47680e 44897b24        mov     dword ptr [rbx+24h],r15d

srvnet!SrvNetAllocateBuffer+0xe2:
; back to rax
fffff804`4a476812 488bc3          mov     rax,rbx

srvnet!SrvNetAllocateBuffer+0xe5:
; [rsp+50h] here is the same as rsp+10h in caller
; I didn't found rsp+10h, and the following either
; rsp+18h
; rsp+20h
; I'm so fucking stupid, this is restoring the value of registers
; see the code at the start of this function, you'll see
fffff804`4a476815 488b5c2450      mov     rbx,qword ptr [rsp+50h]
fffff804`4a47681a 488b6c2458      mov     rbp,qword ptr [rsp+58h]
fffff804`4a47681f 488b742460      mov     rsi,qword ptr [rsp+60h]
fffff804`4a476824 4883c430        add     rsp,30h
fffff804`4a476828 415f            pop     r15
fffff804`4a47682a 415e            pop     r14
fffff804`4a47682c 5f              pop     rdi
fffff804`4a47682d c3              ret

srvnet!SrvNetAllocateBuffer+0xfe:
fffff804`4a47682e 4881e900010000  sub     rcx,100h
fffff804`4a476835 480fbdd1        bsr     rdx,rcx
fffff804`4a476839 480fbcc1        bsf     rax,rcx
fffff804`4a47683d 3bd0            cmp     edx,eax
fffff804`4a47683f 7435            je      srvnet!SrvNetAllocateBuffer+0x146 (fffff804`4a476876)  Branch

srvnet!SrvNetAllocateBuffer+0x111:
fffff804`4a476841 8d72f5          lea     esi,[rdx-0Bh]
fffff804`4a476844 e93bffffff      jmp     srvnet!SrvNetAllocateBuffer+0x54 (fffff804`4a476784)  Branch

srvnet!SrvNetAllocateBuffer+0x119:
fffff804`4a476849 418b4624        mov     eax,dword ptr [r14+24h]
fffff804`4a47684d 8b4b20          mov     ecx,dword ptr [rbx+20h]
fffff804`4a476850 3bc1            cmp     eax,ecx
fffff804`4a476852 732a            jae     srvnet!SrvNetAllocateBuffer+0x14e (fffff804`4a47687e)  Branch

srvnet!SrvNetAllocateBuffer+0x124:
fffff804`4a476854 488b4b18        mov     rcx,qword ptr [rbx+18h]
fffff804`4a476858 894324          mov     dword ptr [rbx+24h],eax
fffff804`4a47685b 498b5618        mov     rdx,qword ptr [r14+18h]
fffff804`4a47685f 448bc0          mov     r8d,eax
fffff804`4a476862 e8d9b20000      call    srvnet!memcpy (fffff804`4a481b40)
fffff804`4a476867 410fb74616      movzx   eax,word ptr [r14+16h]
fffff804`4a47686c 6685c0          test    ax,ax
fffff804`4a47686f 74a1            je      srvnet!SrvNetAllocateBuffer+0xe2 (fffff804`4a476812)  Branch

srvnet!SrvNetAllocateBuffer+0x141:
fffff804`4a476871 e961d40000      jmp     srvnet!SrvNetAllocateBuffer+0xd5a7 (fffff804`4a483cd7)  Branch

srvnet!SrvNetAllocateBuffer+0x146:
fffff804`4a476876 8d72f4          lea     esi,[rdx-0Ch]
fffff804`4a476879 e906ffffff      jmp     srvnet!SrvNetAllocateBuffer+0x54 (fffff804`4a476784)  Branch

srvnet!SrvNetAllocateBuffer+0x14e:
fffff804`4a47687e 8bc1            mov     eax,ecx
fffff804`4a476880 ebd2            jmp     srvnet!SrvNetAllocateBuffer+0x124 (fffff804`4a476854)  Branch

srvnet!SrvNetAllocateBuffer+0xd58e:
fffff804`4a483cbe 4881f900010001  cmp     rcx,1000100h
fffff804`4a483cc5 7730            ja      srvnet!SrvNetAllocateBuffer+0xd5c7 (fffff804`4a483cf7)  Branch

srvnet!SrvNetAllocateBuffer+0xd597:
fffff804`4a483cc7 488bd1          mov     rdx,rcx
fffff804`4a483cca e8f195ffff      call    srvnet!SrvNetAllocateBufferFromPool (fffff804`4a47d2c0)
fffff804`4a483ccf 488bd8          mov     rbx,rax
fffff804`4a483cd2 e9212bffff      jmp     srvnet!SrvNetAllocateBuffer+0xc8 (fffff804`4a4767f8)  Branch

srvnet!SrvNetAllocateBuffer+0xd5a7:
fffff804`4a483cd7 66894316        mov     word ptr [rbx+16h],ax
fffff804`4a483cdb 498d5664        lea     rdx,[r14+64h]
fffff804`4a483cdf 450fb74616      movzx   r8d,word ptr [r14+16h]
fffff804`4a483ce4 488d4b64        lea     rcx,[rbx+64h]
fffff804`4a483ce8 49c1e004        shl     r8,4
fffff804`4a483cec e84fdeffff      call    srvnet!memcpy (fffff804`4a481b40)
fffff804`4a483cf1 90              nop
fffff804`4a483cf2 e91b2bffff      jmp     srvnet!SrvNetAllocateBuffer+0xe2 (fffff804`4a476812)  Branch

srvnet!SrvNetAllocateBuffer+0xd5c7:
fffff804`4a483cf7 33c0            xor     eax,eax
fffff804`4a483cf9 e9172bffff      jmp     srvnet!SrvNetAllocateBuffer+0xe5 (fffff804`4a476815)  Branch
