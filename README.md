I've spent two days to make very detailed comments to almost every line of key functions



here is how windows 1903/1803 fucked up when dealing with SMB2 compression-enabled packet



![image-20220608160949690](README.assets/image-20220608160949690.png)





## how illegal address is accessed

**srv2!Srv2DecompressData**:

![image-20220608155925063](README.assets/image-20220608155925063.png)





I never said RCX is smbpacket, what I only know is that `[rcx+0F0h][18h]` is pointed to smb_header

why? because the data in `[rcx+0F0h][18h]` is the same as wireshark!



so now we know, RAX is a pointer which points to smb_header 

![image-20220608160249534](README.assets/image-20220608160249534.png)



now smb_header is saved into `[rsp+30h]`, smb_header is 0x10bytes, so xmmword(0x10bytes width) is enough



![image-20220608160750948](README.assets/image-20220608160750948.png)

we know `[rsp+30h]` is the very first byte of smb_header, so `[rsp+3Ch]` is 0xC offset in smb_header structure, which is `offset/length` field, value of this field is `0xffffffff`



![image-20220608161259341](README.assets/image-20220608161259341.png)

a very big value(`0x000000010000000f`) is calculated here and passed to RDX

![image-20220608161651213](README.assets/image-20220608161651213.png)

![image-20220608162544590](README.assets/image-20220608162544590.png)

then this value is added to RAX (pointer of smb_header), RDX is now pointing to somewhere unknown



![image-20220608161843422](README.assets/image-20220608161843422.png)

as the second parameter, RDX is passed to `srvnet!SmbCompressionDecompress`

**srvnet!SmbCompressionDecompress**:

![image-20220608161919302](README.assets/image-20220608161919302.png)



![image-20220608161929177](README.assets/image-20220608161929177.png)

![image-20220608162040894](README.assets/image-20220608162040894.png)



R9 passed to `nt!RtlDecompressBufferEx2` as the fourth parameter

**nt!RtlDecompressBufferEx2**:

![image-20220608162126342](README.assets/image-20220608162126342.png)

![image-20220608162137992](README.assets/image-20220608162137992.png)



finally, function `nt!guard_dispatch_icall` will call `nt!RtlDecompressBufferLZNT1`

**nt!RtlDecompressBufferLZNT1**:

![image-20220608162239060](README.assets/image-20220608162239060.png)

![image-20220608162257528](README.assets/image-20220608162257528.png)



target system crashed



## why this address is illegal



because ECX is the allocated size, and ECX overflowed to a little value, it is less than what decompress function needs, so the memory address accessed in decompress function is illegal, as we all know, when user program access illegal memory, os kernel will kill it, so when kernel access illegal memory, crash happens





# lpe

now let's move to new level, evaluate ourself to system privilege

we need some help from IDA, first, I need to figure out how `SrvNetBufferLookasides` is created

use IDA to reverse srvnet.sys, find function `SrvNetAllocateBuffer`,

![image-20220609115339399](README.assets/image-20220609115339399.png)

![image-20220609115414605](README.assets/image-20220609115414605.png)



we chose `SrvNetCreateBufferLookasides` according to the function name

let's bp this function and fire up windbg

to trigger this bp, you need bp it during the target system booting, because `SrvNetCreateBufferLookasides` is created during system initiation



it is so hard, I'm drowning in the sea of kernel code, fuck!!!!!



I see nothing in this function, all buffer is allocated through `nt!ExAllocatePoolWithTagPriority`

not like they said, the custom buffer allocate function is never called, and I don't know how they get this conclusion



I don't know what the fuck I'm doing
